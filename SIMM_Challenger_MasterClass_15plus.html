<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SIMM Challenger MasterClass (15+ pages)</title>
  <script>
    window.MathJax = { tex: {inlineMath: [['$','$'],['\\(','\\)']]} };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    body{font-family:Arial,sans-serif;margin:0;background:#0b1020;color:#e5e7eb}
    .top{position:sticky;top:0;background:#111827;border-bottom:1px solid #374151;padding:10px 14px;z-index:10}
    .top a{color:#93c5fd;margin-right:10px;font-size:13px}
    .page{width:1200px;min-height:680px;margin:22px auto;padding:20px;background:#111827;border:1px solid #374151;border-radius:12px}
    h1,h2,h3{margin:.2rem 0 .6rem 0;color:#f9fafb}
    p,li{line-height:1.45}
    .muted{color:#9ca3af}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:14px}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{border:1px solid #374151;padding:6px;vertical-align:top}
    th{background:#1f2937}
    pre{background:#0f172a;border:1px solid #334155;padding:10px;overflow:auto;color:#d1fae5;font-size:12px}
    .card{border:1px solid #334155;padding:10px;border-radius:8px;background:#0f172a}
    .k{color:#86efac}
    input,button,textarea{background:#1f2937;color:#fff;border:1px solid #475569;padding:6px;border-radius:6px}
    button{cursor:pointer}
    .small{font-size:12px}
  </style>
</head>
<body>
<div class="top">
  <b>SIMM Challenger MasterClass</b>
  <a href="#p1">1</a><a href="#p2">2</a><a href="#p3">3</a><a href="#p4">4</a><a href="#p5">5</a><a href="#p6">6</a>
  <a href="#p7">7</a><a href="#p8">8</a><a href="#p9">9</a><a href="#p10">10</a><a href="#p11">11</a><a href="#p12">12</a>
  <a href="#p13">13</a><a href="#p14">14</a><a href="#p15">15</a><a href="#p16">16</a>
</div>

<section id="p1" class="page"><h1>1) Why SIMM + Why Challenger</h1>
<p>SIMM is the standardized methodology for Initial Margin on uncleared derivatives. A <b>challenger model</b> is required to prove your production engine is correct, explainable, and regulator-defensible.</p>
<ul>
<li><b>Why regulation:</b> post-crisis margin reforms (UMR) require robust IM controls.</li>
<li><b>Why challenger:</b> independent recomputation + evidence chain for audit.</li>
<li><b>Why now:</b> your project includes many exotics where mapping/logic breaks are common.</li>
</ul>
<div class="card">Goal: <span class="k">Independent Pricing/Sensitivity Layer + Independent SIMM Aggregation Layer + Requirement→Test→Evidence traceability.</span></div>
</section>

<section id="p2" class="page"><h1>2) Which Risks? Why six SIMM risk classes?</h1>
<p class="muted">SIMM splits risk because hedging behavior and shock dynamics differ materially.</p>
<table>
<tr><th>Risk Class</th><th>Meaning</th><th>Why separate</th><th>Main Sensitivities</th></tr>
<tr><td>Interest Rate</td><td>Curve level/slope/tenor shifts</td><td>Term-structure specific correlation</td><td>Delta, Vega, Curvature</td></tr>
<tr><td>FX</td><td>Cross-currency spot/forward risk</td><td>Two-rate economics + FX-specific buckets</td><td>Delta, Vega, Curvature</td></tr>
<tr><td>Credit Qualifying</td><td>IG/HY spread risk + base corr products</td><td>Issuer/seniority structure + default correlation</td><td>Delta, Vega, Curvature, BaseCorr</td></tr>
<tr><td>Credit Non-Qualifying</td><td>Non-qualifying credit names</td><td>Different liquidity/risk profile</td><td>Delta, Vega, Curvature</td></tr>
<tr><td>Equity</td><td>Equity spot/vol/sector risk</td><td>Market microstructure differs from IR/FX</td><td>Delta, Vega, Curvature</td></tr>
<tr><td>Commodity</td><td>Commodity spot/term risk</td><td>Delivery/storage and idiosyncratic dynamics</td><td>Delta, Vega, Curvature</td></tr>
</table>
</section>

<section id="p3" class="page"><h1>3) Why sensitivity-based algorithm?</h1>
<div class="grid"><div>
<ul>
<li><b>Transparent:</b> risk explained by first/second-order sensitivities.</li>
<li><b>Scalable:</b> can aggregate large portfolios consistently.</li>
<li><b>Comparable:</b> cross-bank standardization using common RW/correlation rules.</li>
<li><b>Auditable:</b> each IM component traceable to sensitivities and parameters.</li>
</ul></div><div>
<p><b>Core principle:</b> value change approximation</p>
<p>$$\Delta V \approx \sum_i \frac{\partial V}{\partial RF_i}\Delta RF_i + \frac{1}{2}\sum_i \frac{\partial^2 V}{\partial RF_i^2}(\Delta RF_i)^2$$</p>
<p>SIMM operationalizes this with Delta/Vega/Curvature and standardized aggregation.</p>
</div></div>
</section>

<section id="p4" class="page"><h1>4) SIMM technical flow (end-to-end)</h1>
<ol>
<li>Generate sensitivities by trade and risk factor.</li>
<li>Map to SIMM buckets/risk classes/product classes.</li>
<li>Apply risk weights + concentration scaling.</li>
<li>Aggregate within bucket/risk class using prescribed correlations.</li>
<li>Aggregate across risk classes/product classes to total IM.</li>
<li>Run challenger-vs-production variance + RCA.</li>
</ol>
<pre># Conceptual pipeline
sensitivities -> mapping -> weighted_sensitivities -> K_b -> RiskClassMargin -> ProductIM -> TotalIM</pre>
</section>

<section id="p5" class="page"><h1>5) Formula ↔ code mapping (Part A: Delta)</h1>
<p><b>Formula:</b> Weighted sensitivity per factor</p>
<p>$$WS_i = RW_i \times S_i \times CR_i$$</p>
<p><b>Bucket aggregation:</b></p>
<p>$$K_b = \sqrt{\sum_i WS_i^2 + \sum_{i\neq j} \rho_{ij}WS_iWS_j}$$</p>
<pre># Python mapping
for factor in factors:
    ws[factor] = rw[factor] * sensi[factor] * concentration[factor]
Kb = math.sqrt(sum(v*v for v in ws.values()) + sum(rho[i,j]*ws[i]*ws[j] for i!=j))</pre>
</section>

<section id="p6" class="page"><h1>6) Formula ↔ code mapping (Part B: cross aggregation)</h1>
<p><b>Across classes:</b></p>
<p>$$IM = \sqrt{\sum_b K_b^2 + \sum_{b\neq c}\gamma_{bc}S_bS_c}$$</p>
<p>where $S_b=\max(\min(\sum WS_i, K_b),-K_b)$ in SIMM style bounds.</p>
<pre># Python mapping
total = sum(K[b]**2 for b in buckets)
cross = sum(gamma[b,c]*S[b]*S[c] for b in buckets for c in buckets if b<c)
IM = math.sqrt(max(total + 2*cross, 0.0))</pre>
</section>

<section id="p7" class="page"><h1>7) Product universe (20+ categories) and key risk points</h1>
<table>
<tr><th>Family</th><th>Products (examples)</th><th>Key Risk Point</th></tr>
<tr><td>FX Linear</td><td>Spot, Outright Fwd, NDF, FX Swap, Time Option-DF</td><td>Delta mapping, forward points, settlement conventions</td></tr>
<tr><td>FX Vanilla</td><td>Call/Put, premium variants</td><td>Vol surface, smile interpolation</td></tr>
<tr><td>FX Digital</td><td>Cash-or-nothing, one-touch digital</td><td>Discontinuous payoff, unstable Greeks</td></tr>
<tr><td>FX Barrier</td><td>KO/KI/RKO/RKI, KIKO</td><td>Path dependency, barrier monitoring assumptions</td></tr>
<tr><td>FX Structured</td><td>TARF, Pivot TARF, Digital TARF</td><td>State memory, event triggers, leverage asymmetry</td></tr>
<tr><td>Commodity</td><td>Gold vanilla/digital</td><td>Commodity vs FX bucket classification</td></tr>
<tr><td>Rates</td><td>IRS, Basis, CCS, CMS Range Accrual, ARR variants</td><td>Curve mapping, tenor buckets, cross-currency treatment</td></tr>
</table>
</section>

<section id="p8" class="page"><h1>8) Product → Challenger model selection (Which + Why)</h1>
<table>
<tr><th>Product Type</th><th>Model</th><th>Why</th></tr>
<tr><td>FX Linear</td><td>DCF + CIP</td><td>Closed-form, transparent, robust</td></tr>
<tr><td>FX Vanilla</td><td>Garman-Kohlhagen</td><td>Standard FX option benchmark</td></tr>
<tr><td>Digital/Barrier/Touch/KIKO</td><td>Monte Carlo + Brownian Bridge</td><td>Path dependence & discontinuity handling</td></tr>
<tr><td>Gold Option</td><td>Black-76 (forward-based)</td><td>Commodity quotation consistency</td></tr>
<tr><td>TARF family</td><td>State-aware Monte Carlo</td><td>Accrual/trigger memory effects</td></tr>
<tr><td>IRS/Basis/CCS</td><td>Curve PV + bump-and-revalue</td><td>Tenor-level sensitivity control</td></tr>
<tr><td>CMS range accrual</td><td>Hull-White/LMM approximation</td><td>Rate dynamics beyond simple PV</td></tr>
</table>
</section>

<section id="p9" class="page"><h1>9) How each product links to SIMM</h1>
<ul>
<li>Pricing model produces sensitivities in native risk factors.</li>
<li>Mapping layer converts to SIMM factors/buckets.</li>
<li>SIMM engine applies standardized RW/correlation/concentration.</li>
<li>Final IM is model-independent only if mapping + parameters are correct.</li>
</ul>
<pre>Trade -> Pricing/Greeks -> SIMM Mapping -> SIMM Aggregation -> IM
           (model-specific)      (standardized)</pre>
</section>

<section id="p10" class="page"><h1>10) What are risk weights and are they arbitrary?</h1>
<p>No. In SIMM, risk weights are <b>prescribed calibration parameters</b> derived from governance/calibration processes and maintained by ISDA releases. They are not invented per bank model run.</p>
<ul>
<li>Purpose: normalize sensitivities into comparable risk units.</li>
<li>Use: $WS=RW\times S$ before correlation aggregation.</li>
<li>Control: version-locked parameter pack with effective date evidence.</li>
</ul>
</section>

<section id="p11" class="page"><h1>11) Tolerance, variance and RCA</h1>
<table>
<tr><th>Layer</th><th>Metric</th><th>Typical Threshold</th><th>Action</th></tr>
<tr><td>Total IM</td><td>|Δ|/Ref</td><td>&le;1%</td><td>Green: pass</td></tr>
<tr><td>Risk Class</td><td>|Δ|/Ref</td><td>&le;2%</td><td>Amber: review</td></tr>
<tr><td>Sensitivity</td><td>absolute diff</td><td>&le;0.1% notional equiv</td><td>Red: RCA mandatory</td></tr>
</table>
<pre>RCA Tree: Parameter mismatch? -> Mapping mismatch? -> Aggregation logic? -> Source data lineage?</pre>
</section>

<section id="p12" class="page"><h1>12) Regulatory defensibility (HKMA + ISDA)</h1>
<ul>
<li>Requirement → Test → Evidence mapping for every conclusion.</li>
<li>Immutable run logs: input hash, parameter version, code commit, output hash.</li>
<li>No closure without retest evidence + owner + due date.</li>
</ul>
<div class="card">You are not proving “the number looks right”; you are proving “the number is right <b>for the right reason</b>”.</div>
</section>

<section id="p13" class="page"><h1>13) Embedded one-stop interactive demo (no external file required)</h1>
<p class="small">Edit sensitivities below and click compute. This simulates simplified SIMM-style aggregation + variance + RCA hint.</p>
<div class="grid">
<div class="card">
<label>IR sensitivity</label><input id="ir" value="120000"/><br/>
<label>FX sensitivity</label><input id="fx" value="80000"/><br/>
<label>EQ sensitivity</label><input id="eq" value="40000"/><br/>
<label>CRQ sensitivity</label><input id="crq" value="50000"/><br/>
<label>COM sensitivity</label><input id="com" value="30000"/><br/>
<label>Internal IM</label><input id="internal" value="12800"/><br/><br/>
<button onclick="runDemo()">Run Embedded Demo</button>
</div>
<div class="card">
<div id="out">Result appears here.</div>
</div>
</div>
</section>

<section id="p14" class="page"><h1>14) Python demo code (conceptually same as embedded demo)</h1>
<pre>import math
rw = {"IR":0.005,"FX":0.06,"EQ":0.15,"CRQ":0.12,"COM":0.18}
rho = {("IR","FX"):0.18,("IR","EQ"):0.15,("IR","CRQ"):0.10,("IR","COM"):0.12,
       ("FX","EQ"):0.20,("FX","CRQ"):0.12,("FX","COM"):0.22,
       ("EQ","CRQ"):0.25,("EQ","COM"):0.28,("CRQ","COM"):0.20}
S = {"IR":120000,"FX":80000,"EQ":40000,"CRQ":50000,"COM":30000}
K = {k: abs(rw[k]*v) for k,v in S.items()}
keys=list(K)
im2 = sum(K[k]**2 for k in keys)
for i in range(len(keys)):
    for j in range(i+1,len(keys)):
        a,b=keys[i],keys[j]
        im2 += 2*rho[(a,b)]*K[a]*K[b]
IM = math.sqrt(max(im2,0))
print(IM)
</pre>
</section>

<section id="p15" class="page"><h1>15) Meeting script (tomorrow)</h1>
<ol>
<li>State objective: Python-only independent challenger for pricing-sensitivity and SIMM aggregation.</li>
<li>Walk product-by-product model choice and rationale.</li>
<li>Show formula-to-code mapping (pages 5-6, 14).</li>
<li>Run embedded demo live (page 13).</li>
<li>Close with governance: thresholds, RCA, evidence chain.</li>
</ol>
</section>

<section id="p16" class="page"><h1>16) Final checklist (learn + execute)</h1>
<ul>
<li>Can you explain why 6 risk classes exist?</li>
<li>Can you map each major product family to challenger model and SIMM class?</li>
<li>Can you explain each formula and corresponding code block?</li>
<li>Can you explain variance/RCA and audit evidence requirements?</li>
</ul>
<div class="card"><b>If all Yes:</b> you are ready to discuss product-level challenger design with confidence.</div>
</section>

<script>
function runDemo(){
  const S={IR:+ir.value,FX:+fx.value,EQ:+eq.value,CRQ:+crq.value,COM:+com.value};
  const RW={IR:0.005,FX:0.06,EQ:0.15,CRQ:0.12,COM:0.18};
  const rho={"IR|FX":0.18,"IR|EQ":0.15,"IR|CRQ":0.10,"IR|COM":0.12,"FX|EQ":0.20,"FX|CRQ":0.12,"FX|COM":0.22,"EQ|CRQ":0.25,"EQ|COM":0.28,"CRQ|COM":0.20};
  let K={}; Object.keys(S).forEach(k=>K[k]=Math.abs(RW[k]*S[k]));
  const keys=Object.keys(K); let im2=0;
  keys.forEach(k=>im2+=K[k]*K[k]);
  for(let i=0;i<keys.length;i++) for(let j=i+1;j<keys.length;j++){
    const a=keys[i],b=keys[j]; im2 += 2*(rho[a+"|"+b]||rho[b+"|"+a]||0)*K[a]*K[b];
  }
  const im=Math.sqrt(Math.max(im2,0));
  const internalVal=+internal.value; const varPct=((im-internalVal)/Math.max(internalVal,1))*100;
  let rca='Mapping/Aggregation likely';
  if(Math.abs(varPct)<=1) rca='Within tolerance';
  else if(Math.abs(varPct)<=2) rca='Check parameters';
  else rca='RCA required: parameter/mapping/source data/aggregation';
  out.innerHTML=`<h3>Demo Result</h3>
  <p>Computed IM: <b>${im.toFixed(2)}</b></p>
  <p>Internal IM: <b>${internalVal.toFixed(2)}</b></p>
  <p>Variance: <b>${varPct.toFixed(2)}%</b></p>
  <p>RCA Hint: <b>${rca}</b></p>
  <p class='small'>RW and correlations here are simplified for teaching; production must use approved SIMM parameter pack/version.</p>`;
}
</script>
</body>
</html>
